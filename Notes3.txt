__global__ void matrixMul(int* a,int* b,int* c,int rows,int cols,int width){
    int i=threadIdx.x+blockIdx.x*blockDim.x;
    int j=threadIdx.y+blockIdx.y*blockDim.y;

    if(i<rows && j<cols){
        float sum=0.0;
        for(int k=0;k<width;k++){
            sum+=a[i*width+k]*b[k*cols+j];
        }
        c[i*cols+j]=sum;
    }
}

int main(){
    int a[3][2]={{1,2},{3,4},{5,6}};
    int b[2][4]={{5,6,4,11},{7,8,10,18}};
   
    int c[3][4];

    int *cudaA;
    int *cudaB;
    int* cudaC;

    cudaMalloc(&cudaA,sizeof(a));
    cudaMalloc(&cudaB,sizeof(b));
    cudaMalloc(&cudaC,sizeof(c));

    cudaMemcpy(cudaA,a,sizeof(a),cudaMemcpyHostToDevice);
    cudaMemcpy(cudaB,b,sizeof(b),cudaMemcpyHostToDevice);


    int rows=3;
    int cols=4;
    int width=2;
    dim3 threadsPerBlock(3,4);
    //If you use threadsPerBlock(3,2)-> col 1 ,2 are 0
    matrixMul<<<2,threadsPerBlock>>>(cudaA,cudaB,cudaC,rows,cols,width);


    cudaMemcpy(c,cudaC,sizeof(c),cudaMemcpyDeviceToHost);
    cudaFree(cudaA);
    cudaFree(cudaB);
    cudaFree(cudaC);
    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            std::cout<<c[i][j]<<" ";
        }
        std::cout<<"\n";
    }


    
    return 0;

}
