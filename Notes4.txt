__global__ void grid_kernel(){

	int number_threads=blockDimx.x*gridDim.x;
	int thread_id=threadIdx.x+blockDim.x*blockIdx.x;
	

}

which Block Size to use?
	there is no fixed rule
	Use block size that are multiples of 32
	
which grid size to use?
	Depends on the problem size
	
	cuda::ceil_div(input_size,block_size);
	
	int grid_size=(input.size()+block_size-1)/block_size;
	

_syncthreads
	Syncthreads in only available between threads of a given block
	
	
Streaming Multiprocessor (SM) consists of building blocks
Software defined cache called shared memory
	Only accessible within a given thread block and is collocated with L1
	
	
__global__ void kernel(){

	__shared__ int shared[4];
	shared[threadIdx.x]=threadIdx.x;
	__syncthreads();
	
	if(threadIdx.x==0){
		for(int i=0;i<4;i++){
			std::printf("shared[%d]=%d\n",i,shared[i]);
		}
	
	}
}


Threads work independently in parallel.
Matrices are stored in memory in row major format.



Shared memory is organized into 32 banks. Each bank is a slice of SRAM that can load or store 4 bytes of data every cycle.



##############Transposing####################
A->rows*cols
A.T-> cols*rows

__global__ void matrix_transpose_kernel(const float* input, float* output, int rows, int cols) {
    int i=threadIdx.y+blockIdx.y*blockDim.y;
    int j=threadIdx.x+blockIdx.x*blockDim.x;

    if(i<rows && j<cols){
        output[j*rows+i]=input[i*cols+j];
    }
}



################## Matrix Addition ###############

A B C are N*N matrix
__global__ void matrix_add(const float* A, const float* B, float* C, int N) {
    int i=threadIdx.x+blockDim.x*blockIdx.x;

    if(i<N*N){
        C[i]=A[i]+B[i];
    }

}


__global__ void matrixAdd(int* a,int* b,int* c,int rows,int cols){
    int i = threadIdx.x + blockIdx.x * blockDim.x;
    int j = threadIdx.y + blockIdx.y * blockDim.y;

    if(i < rows && j < cols){
        //keep i and j within bounds
        int idx = i * cols + j;
        //CUDA uses linear memory, so 2D matrices are stored as contiguous 1D arrays in row-major order.
        c[idx] = a[idx] + b[idx];
    }
}

